// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: internal/models/model.go

package server_types

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Delivery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Delivery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"phone":`)
	fflib.WriteJsonString(buf, string(j.Phone))
	buf.WriteString(`,"zip":`)
	fflib.WriteJsonString(buf, string(j.Zip))
	buf.WriteString(`,"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteString(`,"region":`)
	fflib.WriteJsonString(buf, string(j.Region))
	buf.WriteString(`,"email":`)
	fflib.WriteJsonString(buf, string(j.Email))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDeliverybase = iota
	ffjtDeliverynosuchkey

	ffjtDeliveryName

	ffjtDeliveryPhone

	ffjtDeliveryZip

	ffjtDeliveryCity

	ffjtDeliveryAddress

	ffjtDeliveryRegion

	ffjtDeliveryEmail
)

var ffjKeyDeliveryName = []byte("name")

var ffjKeyDeliveryPhone = []byte("phone")

var ffjKeyDeliveryZip = []byte("zip")

var ffjKeyDeliveryCity = []byte("city")

var ffjKeyDeliveryAddress = []byte("address")

var ffjKeyDeliveryRegion = []byte("region")

var ffjKeyDeliveryEmail = []byte("email")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Delivery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Delivery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDeliverybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDeliverynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyDeliveryAddress, kn) {
						currentKey = ffjtDeliveryAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyDeliveryCity, kn) {
						currentKey = ffjtDeliveryCity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyDeliveryEmail, kn) {
						currentKey = ffjtDeliveryEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyDeliveryName, kn) {
						currentKey = ffjtDeliveryName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyDeliveryPhone, kn) {
						currentKey = ffjtDeliveryPhone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyDeliveryRegion, kn) {
						currentKey = ffjtDeliveryRegion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffjKeyDeliveryZip, kn) {
						currentKey = ffjtDeliveryZip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryEmail, kn) {
					currentKey = ffjtDeliveryEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryRegion, kn) {
					currentKey = ffjtDeliveryRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDeliveryAddress, kn) {
					currentKey = ffjtDeliveryAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryCity, kn) {
					currentKey = ffjtDeliveryCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryZip, kn) {
					currentKey = ffjtDeliveryZip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryPhone, kn) {
					currentKey = ffjtDeliveryPhone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDeliveryName, kn) {
					currentKey = ffjtDeliveryName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDeliverynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDeliveryName:
					goto handle_Name

				case ffjtDeliveryPhone:
					goto handle_Phone

				case ffjtDeliveryZip:
					goto handle_Zip

				case ffjtDeliveryCity:
					goto handle_City

				case ffjtDeliveryAddress:
					goto handle_Address

				case ffjtDeliveryRegion:
					goto handle_Region

				case ffjtDeliveryEmail:
					goto handle_Email

				case ffjtDeliverynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: j.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zip:

	/* handler: j.Zip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Zip = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Region:

	/* handler: j.Region type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Region = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Item) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Item) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"chrt_id":`)
	fflib.FormatBits2(buf, uint64(j.Chrt_id), 10, j.Chrt_id < 0)
	buf.WriteString(`,"track_number":`)
	fflib.WriteJsonString(buf, string(j.Track_number))
	buf.WriteString(`,"price":`)
	fflib.FormatBits2(buf, uint64(j.Price), 10, j.Price < 0)
	buf.WriteString(`,"rid":`)
	fflib.WriteJsonString(buf, string(j.Rid))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"sale":`)
	fflib.FormatBits2(buf, uint64(j.Sale), 10, j.Sale < 0)
	buf.WriteString(`,"size":`)
	fflib.WriteJsonString(buf, string(j.Size))
	buf.WriteString(`,"total_price":`)
	fflib.FormatBits2(buf, uint64(j.Total_price), 10, j.Total_price < 0)
	buf.WriteString(`,"nm_id":`)
	fflib.FormatBits2(buf, uint64(j.Nm_id), 10, j.Nm_id < 0)
	buf.WriteString(`,"brand":`)
	fflib.WriteJsonString(buf, string(j.Brand))
	buf.WriteString(`,"status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtItembase = iota
	ffjtItemnosuchkey

	ffjtItemChrt_id

	ffjtItemTrack_number

	ffjtItemPrice

	ffjtItemRid

	ffjtItemName

	ffjtItemSale

	ffjtItemSize

	ffjtItemTotal_price

	ffjtItemNm_id

	ffjtItemBrand

	ffjtItemStatus
)

var ffjKeyItemChrt_id = []byte("chrt_id")

var ffjKeyItemTrack_number = []byte("track_number")

var ffjKeyItemPrice = []byte("price")

var ffjKeyItemRid = []byte("rid")

var ffjKeyItemName = []byte("name")

var ffjKeyItemSale = []byte("sale")

var ffjKeyItemSize = []byte("size")

var ffjKeyItemTotal_price = []byte("total_price")

var ffjKeyItemNm_id = []byte("nm_id")

var ffjKeyItemBrand = []byte("brand")

var ffjKeyItemStatus = []byte("status")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Item) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Item) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtItembase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtItemnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyItemBrand, kn) {
						currentKey = ffjtItemBrand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyItemChrt_id, kn) {
						currentKey = ffjtItemChrt_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyItemName, kn) {
						currentKey = ffjtItemName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyItemNm_id, kn) {
						currentKey = ffjtItemNm_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyItemPrice, kn) {
						currentKey = ffjtItemPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyItemRid, kn) {
						currentKey = ffjtItemRid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyItemSale, kn) {
						currentKey = ffjtItemSale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyItemSize, kn) {
						currentKey = ffjtItemSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyItemStatus, kn) {
						currentKey = ffjtItemStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyItemTrack_number, kn) {
						currentKey = ffjtItemTrack_number
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyItemTotal_price, kn) {
						currentKey = ffjtItemTotal_price
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyItemStatus, kn) {
					currentKey = ffjtItemStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyItemBrand, kn) {
					currentKey = ffjtItemBrand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyItemNm_id, kn) {
					currentKey = ffjtItemNm_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyItemTotal_price, kn) {
					currentKey = ffjtItemTotal_price
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyItemSize, kn) {
					currentKey = ffjtItemSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyItemSale, kn) {
					currentKey = ffjtItemSale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyItemName, kn) {
					currentKey = ffjtItemName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyItemRid, kn) {
					currentKey = ffjtItemRid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyItemPrice, kn) {
					currentKey = ffjtItemPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyItemTrack_number, kn) {
					currentKey = ffjtItemTrack_number
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyItemChrt_id, kn) {
					currentKey = ffjtItemChrt_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtItemnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtItemChrt_id:
					goto handle_Chrt_id

				case ffjtItemTrack_number:
					goto handle_Track_number

				case ffjtItemPrice:
					goto handle_Price

				case ffjtItemRid:
					goto handle_Rid

				case ffjtItemName:
					goto handle_Name

				case ffjtItemSale:
					goto handle_Sale

				case ffjtItemSize:
					goto handle_Size

				case ffjtItemTotal_price:
					goto handle_Total_price

				case ffjtItemNm_id:
					goto handle_Nm_id

				case ffjtItemBrand:
					goto handle_Brand

				case ffjtItemStatus:
					goto handle_Status

				case ffjtItemnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Chrt_id:

	/* handler: j.Chrt_id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Chrt_id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Track_number:

	/* handler: j.Track_number type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Track_number = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Price:

	/* handler: j.Price type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Price = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rid:

	/* handler: j.Rid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Rid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sale:

	/* handler: j.Sale type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Sale = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Size:

	/* handler: j.Size type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Size = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Total_price:

	/* handler: j.Total_price type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Total_price = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nm_id:

	/* handler: j.Nm_id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Nm_id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Brand:

	/* handler: j.Brand type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Brand = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Order) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Order) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"order_uid":`)
	fflib.WriteJsonString(buf, string(j.Order_uid))
	buf.WriteString(`,"track_number":`)
	fflib.WriteJsonString(buf, string(j.Track_number))
	buf.WriteString(`,"entry":`)
	fflib.WriteJsonString(buf, string(j.Entry))
	buf.WriteString(`,"delivery":`)

	{

		err = j.Delivery.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"payment":`)

	{

		err = j.Payment.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"items":`)
	if j.Items != nil {
		buf.WriteString(`[`)
		for i, v := range j.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"locale":`)
	fflib.WriteJsonString(buf, string(j.Locale))
	buf.WriteString(`,"internal_signature":`)
	fflib.WriteJsonString(buf, string(j.Internal_signature))
	buf.WriteString(`,"customer_id":`)
	fflib.WriteJsonString(buf, string(j.Customer_id))
	buf.WriteString(`,"delivery_service":`)
	fflib.WriteJsonString(buf, string(j.Delivery_service))
	buf.WriteString(`,"shardkey":`)
	fflib.WriteJsonString(buf, string(j.Shardkey))
	buf.WriteString(`,"sm_id":`)
	fflib.FormatBits2(buf, uint64(j.Sm_id), 10, j.Sm_id < 0)
	buf.WriteString(`,"date_created":`)

	{

		obj, err = j.Date_created.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"oof_shard":`)
	fflib.WriteJsonString(buf, string(j.Oof_shard))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrderbase = iota
	ffjtOrdernosuchkey

	ffjtOrderOrder_uid

	ffjtOrderTrack_number

	ffjtOrderEntry

	ffjtOrderDelivery

	ffjtOrderPayment

	ffjtOrderItems

	ffjtOrderLocale

	ffjtOrderInternal_signature

	ffjtOrderCustomer_id

	ffjtOrderDelivery_service

	ffjtOrderShardkey

	ffjtOrderSm_id

	ffjtOrderDate_created

	ffjtOrderOof_shard
)

var ffjKeyOrderOrder_uid = []byte("order_uid")

var ffjKeyOrderTrack_number = []byte("track_number")

var ffjKeyOrderEntry = []byte("entry")

var ffjKeyOrderDelivery = []byte("delivery")

var ffjKeyOrderPayment = []byte("payment")

var ffjKeyOrderItems = []byte("items")

var ffjKeyOrderLocale = []byte("locale")

var ffjKeyOrderInternal_signature = []byte("internal_signature")

var ffjKeyOrderCustomer_id = []byte("customer_id")

var ffjKeyOrderDelivery_service = []byte("delivery_service")

var ffjKeyOrderShardkey = []byte("shardkey")

var ffjKeyOrderSm_id = []byte("sm_id")

var ffjKeyOrderDate_created = []byte("date_created")

var ffjKeyOrderOof_shard = []byte("oof_shard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Order) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Order) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrderbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrdernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyOrderCustomer_id, kn) {
						currentKey = ffjtOrderCustomer_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyOrderDelivery, kn) {
						currentKey = ffjtOrderDelivery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderDelivery_service, kn) {
						currentKey = ffjtOrderDelivery_service
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderDate_created, kn) {
						currentKey = ffjtOrderDate_created
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyOrderEntry, kn) {
						currentKey = ffjtOrderEntry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyOrderItems, kn) {
						currentKey = ffjtOrderItems
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderInternal_signature, kn) {
						currentKey = ffjtOrderInternal_signature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyOrderLocale, kn) {
						currentKey = ffjtOrderLocale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyOrderOrder_uid, kn) {
						currentKey = ffjtOrderOrder_uid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderOof_shard, kn) {
						currentKey = ffjtOrderOof_shard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyOrderPayment, kn) {
						currentKey = ffjtOrderPayment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOrderShardkey, kn) {
						currentKey = ffjtOrderShardkey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyOrderSm_id, kn) {
						currentKey = ffjtOrderSm_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyOrderTrack_number, kn) {
						currentKey = ffjtOrderTrack_number
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrderOof_shard, kn) {
					currentKey = ffjtOrderOof_shard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderDate_created, kn) {
					currentKey = ffjtOrderDate_created
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderSm_id, kn) {
					currentKey = ffjtOrderSm_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderShardkey, kn) {
					currentKey = ffjtOrderShardkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderDelivery_service, kn) {
					currentKey = ffjtOrderDelivery_service
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderCustomer_id, kn) {
					currentKey = ffjtOrderCustomer_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderInternal_signature, kn) {
					currentKey = ffjtOrderInternal_signature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderLocale, kn) {
					currentKey = ffjtOrderLocale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderItems, kn) {
					currentKey = ffjtOrderItems
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderPayment, kn) {
					currentKey = ffjtOrderPayment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderDelivery, kn) {
					currentKey = ffjtOrderDelivery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderEntry, kn) {
					currentKey = ffjtOrderEntry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyOrderTrack_number, kn) {
					currentKey = ffjtOrderTrack_number
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderOrder_uid, kn) {
					currentKey = ffjtOrderOrder_uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrdernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrderOrder_uid:
					goto handle_Order_uid

				case ffjtOrderTrack_number:
					goto handle_Track_number

				case ffjtOrderEntry:
					goto handle_Entry

				case ffjtOrderDelivery:
					goto handle_Delivery

				case ffjtOrderPayment:
					goto handle_Payment

				case ffjtOrderItems:
					goto handle_Items

				case ffjtOrderLocale:
					goto handle_Locale

				case ffjtOrderInternal_signature:
					goto handle_Internal_signature

				case ffjtOrderCustomer_id:
					goto handle_Customer_id

				case ffjtOrderDelivery_service:
					goto handle_Delivery_service

				case ffjtOrderShardkey:
					goto handle_Shardkey

				case ffjtOrderSm_id:
					goto handle_Sm_id

				case ffjtOrderDate_created:
					goto handle_Date_created

				case ffjtOrderOof_shard:
					goto handle_Oof_shard

				case ffjtOrdernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Order_uid:

	/* handler: j.Order_uid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Order_uid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Track_number:

	/* handler: j.Track_number type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Track_number = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entry:

	/* handler: j.Entry type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Entry = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Delivery:

	/* handler: j.Delivery type=server_types.Delivery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Delivery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Payment:

	/* handler: j.Payment type=server_types.Payment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Payment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: j.Items type=[]server_types.Item kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Items = nil
		} else {

			j.Items = []Item{}

			wantVal := true

			for {

				var tmpJItems Item

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJItems type=server_types.Item kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJItems.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Items = append(j.Items, tmpJItems)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Locale:

	/* handler: j.Locale type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Locale = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Internal_signature:

	/* handler: j.Internal_signature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Internal_signature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Customer_id:

	/* handler: j.Customer_id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Customer_id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Delivery_service:

	/* handler: j.Delivery_service type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Delivery_service = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shardkey:

	/* handler: j.Shardkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Shardkey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sm_id:

	/* handler: j.Sm_id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Sm_id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date_created:

	/* handler: j.Date_created type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Date_created.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oof_shard:

	/* handler: j.Oof_shard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Oof_shard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Payment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Payment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"transaction":`)
	fflib.WriteJsonString(buf, string(j.Transaction))
	buf.WriteString(`,"request_id":`)
	fflib.WriteJsonString(buf, string(j.Request_id))
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"provider":`)
	fflib.WriteJsonString(buf, string(j.Provider))
	buf.WriteString(`,"amount":`)
	fflib.FormatBits2(buf, uint64(j.Amount), 10, j.Amount < 0)
	buf.WriteString(`,"payment_dt":`)
	fflib.FormatBits2(buf, uint64(j.Payment_dt), 10, j.Payment_dt < 0)
	buf.WriteString(`,"bank":`)
	fflib.WriteJsonString(buf, string(j.Bank))
	buf.WriteString(`,"delivery_cost":`)
	fflib.FormatBits2(buf, uint64(j.Delivery_cost), 10, j.Delivery_cost < 0)
	buf.WriteString(`,"goods_total":`)
	fflib.FormatBits2(buf, uint64(j.Goods_total), 10, j.Goods_total < 0)
	buf.WriteString(`,"custom_fee":`)
	fflib.FormatBits2(buf, uint64(j.Custom_fee), 10, j.Custom_fee < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPaymentbase = iota
	ffjtPaymentnosuchkey

	ffjtPaymentTransaction

	ffjtPaymentRequest_id

	ffjtPaymentCurrency

	ffjtPaymentProvider

	ffjtPaymentAmount

	ffjtPaymentPayment_dt

	ffjtPaymentBank

	ffjtPaymentDelivery_cost

	ffjtPaymentGoods_total

	ffjtPaymentCustom_fee
)

var ffjKeyPaymentTransaction = []byte("transaction")

var ffjKeyPaymentRequest_id = []byte("request_id")

var ffjKeyPaymentCurrency = []byte("currency")

var ffjKeyPaymentProvider = []byte("provider")

var ffjKeyPaymentAmount = []byte("amount")

var ffjKeyPaymentPayment_dt = []byte("payment_dt")

var ffjKeyPaymentBank = []byte("bank")

var ffjKeyPaymentDelivery_cost = []byte("delivery_cost")

var ffjKeyPaymentGoods_total = []byte("goods_total")

var ffjKeyPaymentCustom_fee = []byte("custom_fee")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Payment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Payment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPaymentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPaymentAmount, kn) {
						currentKey = ffjtPaymentAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyPaymentBank, kn) {
						currentKey = ffjtPaymentBank
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPaymentCurrency, kn) {
						currentKey = ffjtPaymentCurrency
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPaymentCustom_fee, kn) {
						currentKey = ffjtPaymentCustom_fee
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyPaymentDelivery_cost, kn) {
						currentKey = ffjtPaymentDelivery_cost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyPaymentGoods_total, kn) {
						currentKey = ffjtPaymentGoods_total
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyPaymentProvider, kn) {
						currentKey = ffjtPaymentProvider
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPaymentPayment_dt, kn) {
						currentKey = ffjtPaymentPayment_dt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyPaymentRequest_id, kn) {
						currentKey = ffjtPaymentRequest_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPaymentTransaction, kn) {
						currentKey = ffjtPaymentTransaction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPaymentCustom_fee, kn) {
					currentKey = ffjtPaymentCustom_fee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPaymentGoods_total, kn) {
					currentKey = ffjtPaymentGoods_total
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPaymentDelivery_cost, kn) {
					currentKey = ffjtPaymentDelivery_cost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPaymentBank, kn) {
					currentKey = ffjtPaymentBank
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPaymentPayment_dt, kn) {
					currentKey = ffjtPaymentPayment_dt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPaymentAmount, kn) {
					currentKey = ffjtPaymentAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPaymentProvider, kn) {
					currentKey = ffjtPaymentProvider
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPaymentCurrency, kn) {
					currentKey = ffjtPaymentCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPaymentRequest_id, kn) {
					currentKey = ffjtPaymentRequest_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPaymentTransaction, kn) {
					currentKey = ffjtPaymentTransaction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPaymentTransaction:
					goto handle_Transaction

				case ffjtPaymentRequest_id:
					goto handle_Request_id

				case ffjtPaymentCurrency:
					goto handle_Currency

				case ffjtPaymentProvider:
					goto handle_Provider

				case ffjtPaymentAmount:
					goto handle_Amount

				case ffjtPaymentPayment_dt:
					goto handle_Payment_dt

				case ffjtPaymentBank:
					goto handle_Bank

				case ffjtPaymentDelivery_cost:
					goto handle_Delivery_cost

				case ffjtPaymentGoods_total:
					goto handle_Goods_total

				case ffjtPaymentCustom_fee:
					goto handle_Custom_fee

				case ffjtPaymentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Transaction:

	/* handler: j.Transaction type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Transaction = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Request_id:

	/* handler: j.Request_id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Request_id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Provider:

	/* handler: j.Provider type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Provider = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Amount:

	/* handler: j.Amount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Amount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Payment_dt:

	/* handler: j.Payment_dt type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Payment_dt = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bank:

	/* handler: j.Bank type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bank = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Delivery_cost:

	/* handler: j.Delivery_cost type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Delivery_cost = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Goods_total:

	/* handler: j.Goods_total type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Goods_total = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Custom_fee:

	/* handler: j.Custom_fee type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Custom_fee = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
